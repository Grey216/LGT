# second_task (Реализации циклических очередей на Python)

Этот пакет содержит три реализации циклических очередей на Python: 

- Модуль cdqueue: Реализация циклической очереди на основе deque из модуля collections.
- Модуль caqueue: Реализация циклической очереди на основе массива.
- Модуль cllqueue: Реализация циклической очереди на основе связанного списка.


## Cравнения и пояснения по быстродействию

### CAQueue (Циклическая очередь на основе массива)
- **Реализация**: На основе массива (Array)
- **Преимущества**: 
  - Эффективна для прямого доступа к элементам по индексу.
  - Непрерывный блок памяти массива и именно поэтому обращении к ячеки будет быстрее, чем у связного списка
  - Из-за того что очередь циклическая, то нам нету необходимости пересоздавать заново массив при вставке и удалении 
- **Недостатки**:
  - Менее эффективна для вставки и удаления в середине из-за перемещения данных.
  - Менее эффективна для расширения из-за перемещенния данных из старого массива в новый

### CDQueue (Циклическая очередь с использованием collections.deque)
- **Реализация**: На основе `collections.deque`
- **Преимущества**:
  - Нанмого быстрее для общих операций очереди, таких как вставка, удаление и т.д. 
  - Обеспечивает эффективное управление памятью и изменением размера.
  - Частично реализован на языке C, а значит лучшая производительность из-за оптимизации на более низком уровне
  - Предпочтительный способ использования очереди в своей реализации. Если нужно расширить функционал есть: Наследование, Агригация или Ассоциация
- **Недостатки**:
  - -

### CLLQueue (Циклическая очередь на основе связного списка)
- **Реализация**: На основе связного списка (Linked List)
- **Преимущества**:
  - Эффективна для вставки и удаления в середине, из-за быстрой замены связи
  - Эффективна для расширения
- **Недостатки**:
  - Менее эффективна для прямого доступа с использованием индексации (выделение памяти не последовательное).
  - Занимает больше памяти чем массивы
  - По сравнению с другими способами менеее эфективнен из-за более длительных процессов создания связей Node

## Результаты тестирования

Тестирование проводилось при помощи UnitTest и библиотеки timeit: [ссылка]()

Ниже приведены времена выполнения для различных методов в каждом классе:

| Методы                              | TestCLLQueue | TestCAQueue | TestCDQueue |
|-------------------------------------|--------------|-------------|-------------|
| test_clear                          | 0.0s         | 0.0s        | 0.0s        |
| test_empty                          | 0.0s         | 0.0s        | 0.0s        |
| test_empty_error                    | 0.0s         | 0.0s        | 0.0s        |
| test_front_back                     | 0.0s         | 0.0s        | 0.0s        |
| test_full_error                     | 0.0s         | 0.0s        | 0.0s        |
| test_insert                         | 0.0s         | 0.0s        | 0.0s        |
| test_length                         | 0.0s         | 0.0s        | 0.0s        |
| test_pop                            | 0.0s         | 0.0s        | 0.0s        |
| test_push                           | 0.0s         | 0.0s        | 0.0s        |
| test_push_replace                   | 0.0s         | 0.0s        | 0.0s        |
| test_remove                         | 0.0s         | 0.0s        | 0.0s        |
| test_resize                         | 0.0s         | 0.0s        | 0.0s        |
| test_stress_insert(only insert())   | 0.183s       | 1.67s       | 0.005s      |
| test_stress_insert                  | 1.207s       | 2.012s      | 0.198s      |
| test_stress_pop(only pop())         | 0.481s       | 0.609s      | 0.427s      |
| test_stress_pop                     | 1.622s       | 0.945s      | 0.621s      |
| test_stress_push                    | 1.017s       | 0.339s      | 0.191s      |
| test_stress_push_another_class      | 1.509s       | 0.697s      | 0.562s      |
| test_stress_push_cycle              | 3.284s       | 1.949s      | 1.25s       |
| test_stress_push_replace_cycle      | 0.171s       | 0.09s       | 0.04s       |
| test_stress_remove(only remove())   | 0.003s       | 0.015s      | 0.0s        |
| test_stress_remove                  | 1.045s       | 0.358s      | 0.196s      |
| test_stress_resize(only resize())   | 0.074s       | 0.048s      | 0.017s      |
| test_stress_resize                  | 1.237s       | 0.404s      | 0.214s      |
|-------------------------------------|--------------|-------------|-------------|
| **Общее время**                     | **11.097s**  | **6.876s**  | **3.329s**  |


По результат видно, что большинство основых операций для Очередь лучше всех выполняет collections.deque.

При использовании Очереди на основе связных списков можно заметить, что хоть сами операции вставки по индексу и удаление по элементу обрабатываются быстрее, чем в Очереди на основе массива, но общее время может не отличаться или даже быть хуже. Это связано с тем, что сам процесс создания связей происходит дольше, чем просто ставка элемента в массив. 

В реализацию можно добавить дополнительные методы, такие как: вставка после определенного значения, удаление по индку и т.д. За основу доп. методов для очереди, рассматривалась коллекция deque из пакета collections.
